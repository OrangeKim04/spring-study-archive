# 🌱 Spring Core Principles Study Project

이 프로젝트는 스프링 프레임워크의 핵심 원리를 깊이 있게 이해하기 위해 진행한 학습 리포지토리입니다.
단순한 기능 구현을 넘어, **좋은 객체 지향 설계의 원칙(SOLID)**을 비즈니스 로직에 적용하는 과정과, **스프링 컨테이너가 왜 필요한지**에 대한 기술적 배경을 중점적으로 탐구했습니다.

## 🛠 Development Environment
- **Java**: 17
- **Framework**: Spring Boot 3.x
- **Build**: Gradle
- **Dependencies**: `spring-boot-starter-web`, `lombok`, `jakarta.inject-api`

---

## 📝 Key Learning Objectives (핵심 학습 내용)

### 1. 객체 지향 원리와 스프링의 기본
- **순수 Java 코드로 비즈니스 요구사항 구현**: 다형성(Polymorphism)을 활용한 유연한 설계 시도.
- **기존 코드의 한계점 분석**: 구현 객체를 직접 교체하는 과정에서 발생하는 OCP(개방-폐쇄 원칙), DIP(의존관계 역전 원칙) 위반 사례 분석.
- **DI(Dependency Injection) 도입**: 객체의 **생성**과 **사용**의 책임을 분리하여, 클라이언트 코드의 변경 없이 기능을 확장하는 구조로 리팩토링.

### 2. 스프링 컨테이너와 싱글톤(Singleton)
- **스프링 컨테이너의 역할**: 제어의 역전(IoC)을 담당하는 컨테이너의 동작 원리와 빈(Bean) 관리 메커니즘 학습.
- **싱글톤 패턴과 주의점**: 웹 애플리케이션 환경에서 객체 하나를 공유해서 사용하는 싱글톤 방식의 효율성과, 상태(Stateful) 유지 시 발생할 수 있는 동시성 문제 학습.
- **@Configuration과 바이트코드 조작**: 스프링이 싱글톤을 보장하기 위해 CGLIB를 사용하여 바이트코드를 조작하는 원리 이해.

### 3. 다양한 의존관계 주입과 옵션
- **컴포넌트 스캔(@ComponentScan)**: 설정 정보 없이 자동으로 빈을 등록하는 방법.
- **의존관계 주입 방법론**: 생성자 주입, 수정자 주입, 필드 주입의 차이점과 **생성자 주입을 권장하는 이유(불변, 누락 방지)** 이해.

### 4. 빈 스코프와 생명주기 (Bean Scope & Lifecycle)
- **스코프의 종류**: Singleton, Prototype, Request 스코프의 생성/소멸 시점 차이 학습.
- **스코프 혼용 시 발생하는 문제 해결**:
  - 싱글톤 빈이 프로토타입/리퀘스트 스코프 빈을 의존할 때 발생하는 생명주기 불일치 문제 분석.
  - **해결책 1**: `Provider`(DL)를 사용한 지연 조회.
  - **해결책 2**: `Scoped Proxy Mode`를 사용하여 가짜 프록시 객체를 주입하고, 실제 요청 시 위임(Delegate)하는 방식으로 다형성 활용.

##💡 Conclusion
본 프로젝트를 통해 "스프링은 단순히 개발을 편하게 해주는 도구"가 아니라, **"자바 언어가 가진 객체 지향의 특징을 가장 잘 살려주는 프레임워크"**임을 이해했습니다. 
특히 DI 컨테이너를 통해 결합도를 낮추고 응집도를 높이는 설계가 유지보수에 얼마나 중요한지 코드를 통해 체득할 수 있었습니다.
